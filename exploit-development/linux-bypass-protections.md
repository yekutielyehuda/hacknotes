# Linux Bypass Protections

## Tools

### GEF

Starting up with my favorite which is GEF.  `GEF` (pronounced ʤɛf - "Jeff") is a set of commands for x86/64, ARM, MIPS, PowerPC, and SPARC to assist exploit developers and reverse-engineers when using old school GDB. It provides additional features to GDB using the Python API to assist during the process of dynamic analysis and exploit development. Application developers will also benefit from it, as GEF lifts a great part of regular GDB obscurity, avoiding repeating traditional commands, or bringing out the relevant information from the debugging runtime:

{% embed url="https://github.com/hugsy/gef" %}

### Pwntools

Python Pwntools is a set of python modules that are frequently used in binary exploitation CTF challenges. The installation instructions are available on the project's github website.

{% embed url="https://github.com/Gallopsled/pwntools" %}

The installation can be done using apt and pip.

```
apt-get update 
apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential 
pip install --upgrade 
pip pip install --upgrade pwntools
```

### PEDA

{% embed url="https://github.com/longld/peda" %}

We can install peda as follows:

```
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit
```

## Linux Exploit Protections

We can use another tool to determine what exploit safeguards are in place during the reconnaissance phase, where we try to figure out what the target binary is doing. The checksec script can be used to inspect an executable and display the exploit mitigation it employs.

{% embed url="https://github.com/slimm609/checksec.sh" %}

Checksec can be cloned and installed on the target machine. You can include a symlink to the main script in the path for convenience, so it can be called from anywhere, as seen below.

```
ln –s /full/path/checksec.sh/checksec /usr/bin/checksec
```

## NoExecute

On both 32-bit and 64-bit architectures, No eXecute uses the No eXecute (NX) bit in AMD processors and the Execute Disable Bit (XD) in Intel CPUs. The application will crash with a SIGSEGV if you try to execute any data on the stack, such as after transferring the execution flow back to the stack after a buffer overflow.

The idea is that data on the stack is not executable.

> Note: This mitigation is also often referred to as DEP – Data Execution Prevention.

### Bypassing NX with ret2libc

NX can be readily avoided on its own. When a function call is performed in the x86 architecture, the parameters are pushed onto the stack, and then the function is called. The execution of data on the stack is forbidden in NX, however, having function arguments on the stack is entirely acceptable.

#### LIBC

Libc is the Linux standard C Library, which is installed by default on all computers and contains certain basic functions needed for applications to operate properly. The following command can be used to see if our target binary uses the library.

```
ldd <binary>
```

Alternative, within gdb we can use:

```
vmmap
```

In the terminal, type the following command to get a list of all the functions supplied by your system's libc.

```
nm -D /lib/$(uname -m)-linux-gnu/libc-*.so | grep -vw U | grep -v "_" | cut -d " " -f3
```

#### Offset of Library

What you need to know about libc, or any other library, is that it may be thought of as a collection of functions located at a known offset from the library's base. When you know the library base and version, you'll also know the address of the target function. The offset is the distance between the library's base address and the destination/target function address.

#### Stack

We know that the libc contains some functions that can be used, for example, to start a shell. To call a function, we must first prepare the stack by adding arguments to the function to be called.

Although NX forbids execution from the stack, having arguments there is totally acceptable.

In order to execute a function that is in libc, we need to:

* Find a function that will give us a shell to play with.
* Make sure the stack is appropriately set up.
* Replace the address of the above-mentioned function in the EIP.

You might want to use one of the following that will instantly result in command execution:

* System
* Exec\*

There are also more advanced techniques like:&#x20;

* Using read/write to read/overwrite arbitrary memory ret2strcpy / ret2read / ret2main, etc. to cause another overflow in case the buffer size is limited&#x20;
* Call a chain of functions to alter the execution flow in a complex way

### Vulnerable Code

```c
#include <stdio.h> 
#include <unistd.h>

int overflow() { 
    /* 650 Bytes Wide */
    char buffer[650]; 
    /* Integer Data Type */
    int userinput; 
    /* Read up to 800 Bytes from the user BUT it exceeds the buffer size which 650 Bytes */
    userinput = read(0, buffer, 800); 
    /* Print the amount of bytes and the buffer */
    printf("\nUser provided %d bytes. Buffer content is: %s\n", userinput, buffer); 
    return 0; 
}

int main(int argc, char *argv[]) { 
    overflow(); 
    return 0; 
}
```

gcc is used to compile the source code from the preceding slide. We don't use the -z execstack argument this time since we want the stack to be non-executable (which is supported by default). We don't want the stack protector to be implemented by the compiler, so we'll use the following instruction:

```bash
gcc –fno-stack-protector vulnerable.c –o vulnerable
```

Remember to turn off ASLR with:

```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

### Bypassing NX in Practice

## ASLR

At the operating system level, Address Space Layout Randomization (ASLR) is an exploit countermeasure. When ASLR is enabled, each time a new process is launched, the core memory sections are loaded at a different address.

The ASLR setting is saved in the following file:

```
/proc/sys/kernel/randomize_va_space
```

Only the superuser can write to this file, which can contain the following values:&#x20;

* If ASLR is turned off, the value is 0.&#x20;
* 1  – When ASLR is turned on, the stack, virtual dynamic shared object page, and shared memory regions are all randomized.&#x20;
* 2 – ASLR is enabled, and the data segments are also randomized.

In order to change the ASLR settings on the system, you can type the following from the root user.

```
echo 0 > /proc/sys/kernel/randomize_va_space
```

Using sudo:

```
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

ASLR can be set to one of the above values indefinitely, but this requires superuser privileges. Add the following line at the end of the /etc/sysctl.conf file to do this. Remember that the value can be zero, one, or two.

```
kernel.randomiza_va_space=0
```

After that, reboot the machine or use the following command to compel the system to make the changes immediately:

```
sysctl -p
```

The ldd tool, which prints all the libraries used by an executable along with their addresses, can be used to monitor ASLR in action.

### Bypassing ASLR (abusing low ASLR entropy)

On older systems, if you execute the ldd command on an executable numerous times, you'll observe that the addresses don't differ all that much.

Throughout the binary's runs, only one byte in the middle of the four-byte address changes. If we try to estimate the libc base for a ret2libc-based attack, we have a 1/256 chance of striking a suitable address because the byte's value might be anywhere between 0 and 0xFF. It's also lot easier to brute-force the address of the stack where the shellcode resides in that scenario.

We don't want the stack protector to be implemented by the compiler, so we'll use the following instruction:

```
gcc –fno-stack-protector vulnerable.c –o vulnerable
```

asdf

```
vmmap libc
```

GDB enable ASLR:

```
set disable-randomization off
```

### ASLR Bypass in Practice

First, I’ll check ASLR on the host. I can also see that when I run `ldd` on the binary, the libc address changes each time:

```
www-data@october:/home/harry$ cat /proc/sys/kernel/randomize_va_space 
2
```

Second, we can enumerate the protections with checksec:

```
root@kali# checksec ovrflw
[*] '/media/hackthebox/october-10.10.10.16/ovrflw'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

## Stack Cookie/Canary

Another exploit mitigation that is employed on Linux systems is Stack Cookie, which is also known as stack canary, stack protector, stack guard or SSP.

To compile a binary with a Stack Guard using gcc, add the following flag to the compilation process:

```
-fstack-protector-all
```

There is no universal way to bypass the stack canary protection. Often, creativity might allow you to turn an unexploitable crash into code execution and a stack canary bypass.

To get around a canary protection, you must first be able to answer the following questions:

* What is the value of the canary?&#x20;
* Which type of canary is it?&#x20;
* Which function in the program is vulnerable?
* Which characters are allowed?&#x20;
* Is it possible to exploit the vulnerability before the function returns?&#x20;
* Is it vulnerable to bruteforce?

### Bypassing Stack Cookies

## RELRO

RELRO stands for RELocation Read Only. It’s an exploit mitigation that protects data sections of a process from overwriting during an exploitation process.

A dynamically linked ELF binary contains the Global Offset Table (GOT) in order to dynamically resolve functions located in shared libraries.

The process of resolving the function address is similar to the below:

* Call to functions actually points to PLT (Procedure Linkage Table) in the .plt section.
* PLT points to a function address in GOT. GOT is actually residing in the .plt.got section.&#x20;
* GOT contains pointers back to PLT, where the final address of the function is stored.

With Partial RELRO, exploitation of arbitrary write is still possible. Partial RELRO can be forced during compilation using the below gcc arguments.

```
-Wl,-z,relro
```

Full RELRO does the same as partial, plus it has some additional protections:

* The linker will perform all the symbol lookups at link time (before execution starts) and then it will remove the write permissions from the GOT.&#x20;
* .got.plt becomes part of .got.

In order to force full RELRO, additional arguments have to be supplied to gcc, as follows.

```
-Wl,-z,relro,-z,now
```

With full RELRO, exploitation of an arbitrary write is not possible – at least not by overwriting GOT entries.&#x20;
