# Linux Bypass Protections

## Tools

Starting up with my favorite which is GEF.  `GEF` \(pronounced ʤɛf - "Jeff"\) is a set of commands for x86/64, ARM, MIPS, PowerPC, and SPARC to assist exploit developers and reverse-engineers when using old school GDB. It provides additional features to GDB using the Python API to assist during the process of dynamic analysis and exploit development. Application developers will also benefit from it, as GEF lifts a great part of regular GDB obscurity, avoiding repeating traditional commands, or bringing out the relevant information from the debugging runtime:

{% embed url="https://github.com/hugsy/gef" %}

Python Pwntools is a set of python modules that are frequently used in binary exploitation CTF challenges. The installation instructions are available on the project's github website.

{% embed url="https://github.com/Gallopsled/pwntools" %}

The installation can be done using apt and pip.

```text
apt-get update 
apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential 
pip install --upgrade 
pip pip install --upgrade pwntools
```

## Linux Exploit Protections

We can use another tool to determine what exploit safeguards are in place during the reconnaissance phase, where we try to figure out what the target binary is doing. The checksec script can be used to inspect an executable and display the exploit mitigation it employs.

{% embed url="https://github.com/slimm609/checksec.sh" %}

Checksec can be cloned and installed on the target machine. You can include a symlink to the main script in the path for convenience, so it can be called from anywhere, as seen below.

```text
ln –s /full/path/checksec.sh/checksec /usr/bin/checksec
```

## NoExecute

On both 32-bit and 64-bit architectures, No eXecute uses the No eXecute \(NX\) bit in AMD processors and the Execute Disable Bit \(XD\) in Intel CPUs. The application will crash with a SIGSEGV if you try to execute any data on the stack, such as after transferring the execution flow back to the stack after a buffer overflow.

The idea is that data on the stack is not executable.

> Note: This mitigation is also often referred to as DEP – Data Execution Prevention.

### Bypassing NX with ret2libc

NX can be readily avoided on its own. When a function call is performed in the x86 architecture, the parameters are pushed onto the stack, and then the function is called. The execution of data on the stack is forbidden in NX, however, having function arguments on the stack is entirely acceptable.

We control the data sent on the stack as it overflows with our custom buffer during a stack overflow. To get around the NX protection, we can include function parameters in the buffer and then point the EIP to another function that will use them. There are a variety of functions that can be used for this. They can be found in the executable itself or any library used by it.

The subsequent techniques we'll see are all members of the "ret2" family. They're called that because we're returning from the stack to another part of the program. You may have come across names like ret2libc or ret2system. The standard C library named LIBC is the most prevalent among the several libraries that software uses in the Linux environment.

#### LIBC

Libc is the Linux standard C Library, which is installed by default on all computers and contains certain basic functions needed for applications to operate properly. The following command can be used to see if our target binary uses the library.

```text
ldd <binary>
```

Alternative, within gdb we can use:

```text
vmmap
```

In the terminal, type the following command to get a list of all the functions supplied by your system's libc.

```text
nm -D /lib/$(uname -m)-linux-gnu/libc-*.so | grep -vw U | grep -v "_" | cut -d " " -f3
```

#### Offset of Library

What you need to know about libc, or any other library, is that it may be thought of as a collection of functions located at a known offset from the library's base. When you know the library base and version, you'll also know the address of the target function. The offset is the distance between the library's base address and the destination/target function address.

#### Stack

We know that the libc contains some functions that can be used, for example, to start a shell. To call a function, we must first prepare the stack by adding arguments to the function to be called.

Although NX forbids execution from the stack, having arguments there is totally acceptable.

In order to execute a function that is in libc, we need to:

* Find a function that will give us a shell to play with.
* Make sure the stack is appropriately set up.
* Replace the address of the above-mentioned function in the EIP.

You might want to use one of the following that will instantly result in command execution:

* System
* Exec\*

There are also more advanced techniques like: 

* Using read/write to read/overwrite arbitrary memory ret2strcpy / ret2read / ret2main, etc. to cause another overflow in case the buffer size is limited 
* Call a chain of functions to alter the execution flow in a complex way

### Vulnerable Code

```c
#include <stdio.h> 
#include <unistd.h>

int overflow() { 
    /* 650 Bytes Wide */
    char buffer[650]; 
    /* Integer Data Type */
    int userinput; 
    /* Read up to 800 Bytes from the user BUT it exceeds the buffer size which 650 Bytes */
    userinput = read(0, buffer, 800); 
    /* Print the amount of bytes and the buffer */
    printf("\nUser provided %d bytes. Buffer content is: %s\n", userinput, buffer); 
    return 0; 
}

int main(int argc, char *argv[]) { 
    overflow(); 
    return 0; 
}
```

gcc is used to compile the source code from the preceding slide. We don't use the -z execstack argument this time since we want the stack to be non-executable \(which is supported by default\). We don't want the stack protector to be implemented by the compiler, so we'll use the following instruction:

```bash
gcc –fno-stack-protector vulnerable.c –o vulnerable
```

Remember to turn off ASLR with:

```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

### Bypassing NX in Practice

## ASLR

At the operating system level, Address Space Layout Randomization \(ASLR\) is an exploit countermeasure. When ASLR is enabled, each time a new process is launched, the core memory sections are loaded at a different address.

The ASLR setting is saved in the following file:

```text
/proc/sys/kernel/randomize_va_space
```

Only the superuser can write to this file, which can contain the following values: 

* If ASLR is turned off, the value is 0. 
* 1  – When ASLR is turned on, the stack, virtual dynamic shared object page, and shared memory regions are all randomized. 
* 2 – ASLR is enabled, and the data segments are also randomized.

In order to change the ASLR settings on the system, you can type the following from the root user.

```text
echo 0 > /proc/sys/kernel/randomize_va_space
```

Using sudo:

```text
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

ASLR can be set to one of the above values indefinitely, but this requires superuser privileges. Add the following line at the end of the /etc/sysctl.conf file to do this. Remember that the value can be zero, one, or two.

```text
kernel.randomiza_va_space=0
```

After that, reboot the machine or use the following command to compel the system to make the changes immediately:

```text
sysctl -p
```

The ldd tool, which prints all the libraries used by an executable along with their addresses, can be used to monitor ASLR in action.

### Bypassing ASLR \(abusing low ASLR entropy\)

On older systems, if you execute the ldd command on an executable numerous times, you'll observe that the addresses don't differ all that much.

Throughout the binary's runs, only one byte in the middle of the four-byte address changes. If we try to estimate the libc base for a ret2libc-based attack, we have a 1/256 chance of striking a suitable address because the byte's value might be anywhere between 0 and 0xFF. It's also lot easier to brute-force the address of the stack where the shellcode resides in that scenario.

We don't want the stack protector to be implemented by the compiler, so we'll use the following instruction:

```text
gcc –fno-stack-protector vulnerable.c –o vulnerable
```

asdf

```text
vmmap libc
```

GDB enable ASLR:

```text
set disable-randomization off
```

### ASLR Bypass in Practice

## Stack Cookie/Canary

Another exploit mitigation that is employed on Linux systems is Stack Cookie, which is also known as stack canary, stack protector, stack guard or SSP.

Stack canary is a 4-byte value that is pushed onto the stack when a function is entered. When the function ends its task, and the stack frame is cleared, the stack cookie value is checked against the previously pushed value. If it’s different, the program is terminated by calling the \_\_stack\_chk\_fail function.

Of course, there could be custom implementations, but they are not likely to be more effective. For example, on a custom implementation it is possible that the cookie value is hardcoded in a variable. This value can be easily obtained during reverse-engineering the target binary.

Signs that a stack canary is being used are: • “Stack smashing detected” displayed at an overflow attempt • Calls to \_\_stack\_chk\_fail or similar functions in the disassembly

To compile a binary with a Stack Guard using gcc, add the following flag to the compilation process:

```text
-fstack-protector-all
```

There is no universal way to bypass the stack canary protection. Often, creativity might allow you to turn an unexploitable crash into code execution and a stack canary bypass.

In order to bypass a canary protection, you should be able to answer following questions first: • What is the value of the canary? Is it different for each run of the program? Try to spot it each time in the dbg and note its value. • What type of canary is it? Use the types presented earlier to categorize the canary you are dealing with. • What function in the program is vulnerable? What are the allowed characters? • Is it possible to exploit the vulnerability before the function returns? • Is the exploit remote or local? Can we bruteforce the canary?

We will use a practical example to show how a stack canary bypass might look like. We will use Ubuntu 18 64-bit, a 32bit vulnerable application and the python pwntools.

### Bypassing Stack Cookies

## RELRO

RELRO stands for RELocation Read Only. It’s an exploit mitigation that protects data sections of a process from overwriting during an exploitation process.

A dynamically linked ELF binary contains the Global Offset Table \(GOT\) in order to dynamically resolve functions located in shared libraries.

The process of resolving the function address is similar to the below:

* Call to functions actually points to PLT \(Procedure Linkage Table\) in the .plt section.
* PLT points to a function address in GOT. GOT is actually residing in the .plt.got section. 
* GOT contains pointers back to PLT, where the final address of the function is stored.

The purpose of resolving symbols that are about to be used, is a performance enhancement. We resolve only functions that are used during runtime, as not all the functions \(.got and .got.plt\) should be writable.

In case the attacker is able to perform an arbitrary write of just 4 bytes, he can hijack the global offset table and change the address of a resolved function \(e.g.- exit\) to point to the location where the shellcode is stored.

What’s the role of RELRO in all of this? There are two stages of RELRO – partial and full.

Partial RELRO that maps a .got section as read-only but .got.plt is still writable

With Partial RELRO, exploitation of arbitrary write is still possible. Partial RELRO can be forced during compilation using the below gcc arguments.

```text
-Wl,-z,relro
```

Full RELRO does the same as partial, plus it has some additional protections:

* The linker will perform all the symbol lookups at link time \(before execution starts\) and then it will remove the write permissions from the GOT. 
* .got.plt becomes part of .got.

In order to force full RELRO, additional arguments have to be supplied to gcc, as follows.

```text
-Wl,-z,relro,-z,now
```

With full RELRO, exploitation of an arbitrary write is not possible – at least not by overwriting GOT entries. There can still be other conditions in the target binary that might be exploitable in an unconventional, creative way! Additionally, there is no direct RELRO bypass. However, the price of weaker performance is often too high for the developers to implement FULL RELRO in binaries. Full RELRO, once spotted, informs you that you cannot overwrite GOT/PLT entries.

