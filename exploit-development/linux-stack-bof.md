# Linux Stack Buffer Overflow

## ELF Fundamentals

The Linux and Unix executable file format is ELF (Executable and Linking Format). An ELF file is made up of two parts: an ELF header and ELF data. The readelf command can be used to inspect it. The ELF header provides vital information to the operating system on how to handle the file.

Types include CORE (core dumps), DYN (shared objects), EXEC (executables), and REL (relational databases) (relocatable files).

Memory corruption results in core dumps. They can be supplied into gdb to help debug crashing applications more thoroughly. Core dumps will be used later in the exploit building process.

### Linkers & Loaders

Linkers are in charge of connecting the names of functions to their actual locations in memory. The linker is responsible for identifying a function's memory address within a system library and writing it to the executable's process memory so that the function can be accessed at that address. A loader's job is to load programs from disk into memory.

It is necessary to relocate an executable that seeks to be loaded at a memory address that is already occupied. To avoid address collisions, relocating the module simply involves moving it to a different location in memory.

ELF files have a.reloc section because this should be done in a systematic manner. The `.reloc` section is responsible for patching the program with new addresses if the requested loading address is unavailable. Relative addressing is utilized to describe the address of program functions in order to do this.

### RVA

The offset from the loading base address, rather than the complete address, is used to define a function address in relative addressing.

### Symbols

Furthermore, executable files might also contain symbols. Symbols are a description of the executable code and include, among others, function and variable names.

> Note: During compilation you can turn off support for symbols.

Symbols make debugging much easier because many function and variable names provide hints as to what they are supposed to accomplish; for example, locating functions titled "getName()" or "printName()" might save us a lot of time and effort in reverse engineering.

**Stripping** is the process of removing symbols from an ELF file.

### Summary

Executable files can be mapped directly into memory upon execution.

Executables that facilitate the relocation process are known as **relocatable files**. They use relative addressing to modify the address of their components with a consistent offset to their dynamic base address in the event of an address dispute.

Shared Objects are function libraries. They contain portions that are common to both executable and relocatable files from a technological standpoint. The `.so` extension is typically used to identify them. During startup, shared objects are loaded into a program that uses them.

#### Sections & Mapping

Sections are regular locations in an ELF file that serve a specific role in the file's functionality. Sections are mapped into the process memory during startup. Mapping refers to the act of storing them in the memory of a newly generated process based on their size and data content. Sections also have permissions – read, write, and execute – of which none or all can theoretically be abused.

The following are the most common sections: data — Data that has been initialized and has read/write permissions. rodata — Data that has been initialized with read-only access privileges. bss – Data that hasn't been initialized but has read and write permissions.

## GOT & PLT

There are two essential components for an executable: Function addresses are stored in the Global Offset Table (.GOT). The .PLT file stores the function stubs that point to the.GOT entry (Procedure Linkage Table). When a program tries to locate and call a certain function, both (the PLT first, then the GOT) are used, as you might anticipate.

> Note that a place in the program where function addresses are held will become more than useful during exploit development.

## SUID & SGID

When it comes to exploitation on Linux and Unix, SUID files are a sort of ELF file that is highly fascinating. On Linux and Unix, SUID and SGID files are identified by the lowercase "s" in their security descriptor.

```
-rwsr-s--x
```

When you run a SUID (Set User IDentification) or SGID (Set Group IDentification) software, the file's effective UID (or GID) becomes the owner. When you run a SUID root program, it executes with root rights. When you launch an SGID program, it runs with the same permissions as if you were a member of that group.

## Stack Buffer Overflow

### Finding Segmentation Fault

![500 A's in the overflw binary](<../.gitbook/assets/image (11).png>)



